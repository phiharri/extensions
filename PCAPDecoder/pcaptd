#!/usr/bin/env python 
#
# Copyright (c) 2013 Arista Networks, Inc.  All rights reserved.
# Arista Networks, Inc. Confidential and Proprietary.
#
# PCAP Timestamp Decoder
#
#    Version 1.1 6/6/2013
#    Written by: 
#       John Peach, Arista Networks
#       Andrei Dvornic, Arista Networks
#
#    Revision history:
#       1.0 - initial release
#       1.1 - added key frame support
#           - added command line options
#       2.0 - added support for devId-VLAN mapping

'''
   DESCRIPTION
      PCAP Timestamp Decoder enables users to decode the timestamps
      applied by the Arista 7150 series switches.

   INSTALLATION
      Requirements: 
         - Python 2.6 or later: http://www.python.org/
         - dpkt: http://code.google.com/p/dpkt/

      In order to install PCAP Timestamp Decoder, copy 'pcaptd' to
      your filesystem.

      Define the mapping between the device id in the key frames and the
      VLANs corresponding to the packets timestamped through that device
      in the highlighted section below, at the beginning of the script.

      Once the mapping is configured, the PCAP Timestamp Decoder can
      then be started using:
      
         (bash:root)# <path-to-script>/pcaptd [<options>] <input_pcap>

   CONFIGURATION 
      By default, the decoder assumes that the input pcap
      file contains timestamps which replace the FCS. If the timestamp
      was added before the FCS, please use the '--fcs' command-line
      option.  
      e.g.  
         (bash:root)# /mnt/flash/pcaptd --fcs <input_pcap>

      In order to print the results to a file, use the '--output-file'
      option. This is recommended for large input pcap files.

      The following options can be used in order to change the output of 
      the script:

         -d, --delta           show delta between consecutive packets
         -p, --pcap-timestamps show pcap timestamps
         -r, --recover-utc     show UTC time
         -s, --src-ip          show source IP
         -t, --ticks           show hw timestamps as ticks

      Notes:
        - R:       rollback
        - KEY:     key frame
        - R/KEY:   rollback on key frame
   
   COMPATIBILITY 
      Version 1.1 has been developed and tested against
      Python 2.7 on MacOS, but should work on any other operating
      system supporting Python 2.6 or later. Please reach out to
      support@aristanetworks.com for assistance if needed.

   LIMITATIONS
      The tool tries to detect a counter rollover (by checking if a
      subsequent timestamp has a lower tick value than it
      predecessor). However, this mechanism does not uncover periods
      where the inter-timestamp delta is < 6.15s. This can result in
      undetected rollovers, if:

            6.15s < delta < (2 * 6.15 - previous timestamp)

      Multiple rollovers cannot be tracked and may go undetected.


      Decoding the UTC timestamp uses the information contained in the
      latest key frame which was processes. This might not be the
      'most recent' mapping between the hw timestamp and UTC time,
      because that might arrive in the following key frame. This limitation
      will be addressed in subsequent releases.

      e.g. 
           UTC mapping collected     t0
           key frame sent            t1      
           packet sent               t3
           UTC mapping collected     t4
           packet sent               t5
           key frame sent            t6

           Packet with timestamp t5 will be decoded using mapping
           collected at t0, and not t4.

      Because of the same issue, packets received before the first
      key frame are not decoded.


      Rollover detection is using a 0.6s buffer in order to avoid
      false positives which might happen due the capture card
      reporting out-of-order packets. This means that rollovers where
      the delay between packets is ~6.135s will not be detected. A
      knob to turn this on/off will be added in subsequent releases.
'''



# ------------------------------------------------------------
# !!! INSERT deviceId -> VLAN mapping below !!!
# e.g. 
#    VLAN10 timestamped through device 1
#    VLAN20 and VLAN30 timestamped through device 2
#
# vlanToDevId = {}
# vlanToDevId[ 1 ] = 10
# vlanToDevId[ 2 ] = 20
# vlanToDevId[ 2 ] = 30

vlanToDevId = {}
vlanToDevId[ 10 ] = 10
vlanToDevId[ 20 ] = 0
#-------------------------------------------------------------




import binascii
import dpkt
import optparse
import string
import socket
import sys

from datetime import datetime

# Based on the clock rate (350Mhz)
TICK_LENGTH = 2.857
MAX_TICKS = 2**31

# { deviceId : [ asicTime, utcTime ] }
ticksToUTC = {}

# { deviceId : <value> }
prevHwTicks = {}
prevPcapTime = {}
prevUtc = {}

class VLANEthernet( dpkt.ethernet.Ethernet ):
   __hdr__ = (
       ( 'dst', '6s', '' ),
       ( 'src', '6s', '' ),
       ( '__VLAN__', 'H', dpkt.ethernet.ETH_TYPE_8021Q ),
       ( 'vlan', 'H', 1 ),
       ( 'type', 'H', dpkt.ethernet.ETH_TYPE_IP )
       )
   _typesw = {}

def _printTimestamps( data, showPcap, showUTC, showTicks, showDelta, 
                      showSourceIp, filename=None ):

   units = 'ticks'
   if not showTicks:
      units = 'ns'

   header = [ string.rjust( 'PCAP tstamp(s)', 18 ) 
                 if showPcap else '',
              string.rjust( 'PCAP delta(ns)', 18 ) 
                 if showPcap and showDelta else '',
              string.rjust( 'HW tstamp(%s)' % units, 18 ),
              string.rjust( 'HW delta(%s)' % units, 18 ) 
                 if showDelta else '',
              string.rjust( 'UTC(ns)', 20 ) if showUTC else '',
              string.rjust( 'UTC delta(ns)', 15 ) 
                 if showUTC and showDelta else '',
              string.rjust( 'UTC', 30 ) 
                 if showUTC and showDelta else '',
              string.rjust( 'Source IP', 15 ) 
                 if showSourceIp else '',
              string.rjust( 'VLAN/DeviceId(VLANs)', 20 ),
              string.rjust( 'Note', 5 ) ]

   if filename:
      try:
         f = open( filename, 'w' )
      except IOError, e:
         print '\nUnable to open file %s: %s\n' % ( filename, str( e ) )
         sys.exit()

      f.write( ' '.join( header ) + '\n' )
   else:
      print ' '.join( header )

   for [ pcapTs, pcapDelta, hwTicks, hwDelta, 
         utcTime, utcDelta, rollover, keyFrame, 
         srcIp, vlanOrDevId ] in data:
      note = ''
      if rollover:
         note = 'R'
         if keyFrame:
            note = 'R/KEY'
      elif keyFrame:
         note = 'KEY'

      utcString = datetime.utcfromtimestamp( 
                     utcTime / 10.0**9 ).strftime( '%Y-%m-%d %H:%M:%S.%f' )

      if showTicks:
         hwString = '%d' % hwTicks
         hwDeltaString = '%d' % hwDelta
      else: 
         hwString = '%1.2f' % ( hwTicks * TICK_LENGTH )
         hwDeltaString = '%1.2f' % ( hwDelta * TICK_LENGTH )
         
      if keyFrame:
         vlanOrDevIdString = \
             '%d(%s)' % ( vlanOrDevId, 
                          ','.join( [ str( x ) 
                                      for x in vlanToDevId 
                                      if vlanToDevId[ x ] == vlanOrDevId ] ) )
      else:
         vlanOrDevIdString = 'VLAN%s' % vlanOrDevId

      row = [ string.rjust( '%1.6f' % pcapTs, 18 ) 
                 if showPcap else '',
              string.rjust( '%1.6f' % pcapDelta if pcapDelta else '', 18 ) 
                 if showPcap and showDelta else '',
              string.rjust( hwString, 18 ),
              string.rjust( hwDeltaString if hwDelta else '', 18 ) 
                 if showDelta else '',
              string.rjust( '%d' % utcTime if utcTime else 'N/A', 20 ) 
                 if showUTC else '',
              string.rjust( ( '%1.0f' % utcDelta if utcDelta else '' ) 
                            if utcTime else 'N/A', 15 ) 
                 if showUTC  and showDelta else '',
              string.rjust( utcString if utcTime else 'N/A', 30 ) 
                 if showUTC else '',
              string.rjust( socket.inet_ntoa( srcIp ) if srcIp else 'N/A', 15 ) 
                 if showSourceIp else '',
              string.rjust( vlanOrDevIdString, 20 ),
              string.rjust( note, 5 ) ]

      if filename:
         f.write( ' '.join( row ) + '\n' )
      else:
         print ' '.join( row )

   if filename:
      f.close()

def _timestampDetails( pcapTs, hwTicks, vlan=None, deviceId=None, key=False ):

   if key:
      assert deviceId != None
   else:
      assert vlan != None

   rollover = False
   hwDelta = 0

   devId = deviceId
   if not key:
      devId = vlanToDevId[ vlan ]

   if devId in prevHwTicks:
      # We assume at least 1% buffer for rollover detection in order
      # to avoid false positives (out-of-order packets).  Of course,
      # this means that some rollovers (where the gap between packets
      # ~6.135s) will remain undetected.
      if prevHwTicks[ devId ] - hwTicks > ( MAX_TICKS / 100 ):
         hwDelta = MAX_TICKS - prevHwTicks[ devId ] + hwTicks
         rollover = True
      else:
         hwDelta = hwTicks - prevHwTicks[ devId ]
   prevHwTicks[ devId ] = hwTicks

   pcapDelta = 0
   if devId in prevPcapTime:
      pcapDelta = ( pcapTs - prevPcapTime[ devId ] ) * 10**9
   prevPcapTime[ devId ] = pcapTs

   utc = 0
   if devId in ticksToUTC:
      [ asicTime, utcTime ] = ticksToUTC[ devId ][ -1 ]
      shortAsicTime = ( asicTime & 0x7FFFFFFF )

      # Rollover (see previous comment)
      if shortAsicTime - hwTicks > ( MAX_TICKS / 100 ):
         diff = MAX_TICKS - shortAsicTime + hwTicks
      else:
         diff = hwTicks - shortAsicTime

      utc = utcTime + long( round( diff * TICK_LENGTH ) )

   utcDelta = 0
   if devId in prevUtc and prevUtc[ devId ]:
      utcDelta = ( utc - prevUtc[ devId ] )
   prevUtc[ devId ] = utc

   return [ pcapTs, pcapDelta, hwTicks, hwDelta, 
            utc, utcDelta, rollover ]

def _readTimestamps( f, fcs ):

   try:
      f = open( f )
   except IOError, e:
      print '\nUnable to open file %s: %s\n' % ( f, str( e ) )
      sys.exit()

   # [ [ pcampTstamp, pcapDelta, hwTicks, hwDelta, 
   #     utc, utcDelta, rollOver, keyFrame, srcIp, 
   #     vlan/deviceId ] ]
   data = []

   print '\nLoading input file...\n'
   for pcapTs, buf in dpkt.pcap.Reader( f ):
      eth = dpkt.ethernet.Ethernet( buf )
      vlan = VLANEthernet( buf ).vlan

      # Key frame
      if eth.type == 2048 and eth.ip.p == 253 and eth.ip.ttl == 64:

         asicTime = int( '0x' + binascii.hexlify( eth.ip.data[ 0 : 8 ] ), 0 )
         utcTime = int( '0x' + binascii.hexlify( eth.ip.data[ 8 : 16 ] ), 0 )
         deviceId = int( '0x' + binascii.hexlify( eth.ip.data[ 40 : 42 ] ), 0 )

         if deviceId not in ticksToUTC:
            ticksToUTC[ deviceId ] = []
         ticksToUTC[ deviceId ] += [ [ asicTime, utcTime ] ]

         stamp =  int( '0x' + binascii.hexlify( eth.ip.data[ 25 : 32 ] ), 0 )
         hwTicks = stamp & 0x7FFFFFFF
         data += [ _timestampDetails( pcapTs, hwTicks, 
                                      deviceId=deviceId, key=True ) + 
                   [ True, eth.ip.src, deviceId ] ]
      else:
         # Ignore packets which don't belong to the configured VLANs
         if vlan not in vlanToDevId:
            continue

         if fcs:
            stamp = int( '0x' + binascii.hexlify( buf[ -8 : -4 ] ), 0 )
         else:
            stamp = int( '0x' + binascii.hexlify( buf[ -4 : ] ), 0 )
      
         hwTicks = ( ( stamp & 0xffffff00 ) >> 1 ) | ( stamp & 0x7f )
         data += [ _timestampDetails( pcapTs, hwTicks, vlan=vlan ) + 
                   [ False, eth.ip.src if eth.type == 2048 else None, vlan ] ]

   return data

def main():
   if not vlanToDevId:
      print 'Please configure the deviceId->VLAN mapping at the top of the script!' 
      sys.exit()

   # Create help string and parse cmd line
   usage = 'usage: %prog [options] <input-filename>'
   op = optparse.OptionParser(usage=usage)
   op.add_option( '-f', '--fcs', dest='fcs', 
                  action='store_true', help='pcap frames have valid fcs' )
   op.add_option( '-d', '--delta', dest='delta', 
                  action='store_true', help='show delta between consecutive '
                                            'packets' )
   op.add_option( '-p', '--pcap-timestamps', dest='pcap', 
                  action='store_true', help='show pcap timestamps' )
   op.add_option( '-o', '--output-file', dest='filename', 
                  action='store', help='output file' )
   op.add_option( '-r', '--recover-utc', dest='utc', 
                  action='store_true', help='show UTC time' )
   op.add_option( '-s', '--src-ip', dest='src', 
                  action='store_true', help='show source IP' )
   op.add_option( '-t', '--ticks', dest='ticks', 
                  action='store_true', help='show hw timestamps as ticks' )
   opts, arguments = op.parse_args()
 
   # Check cmd line options
   if not arguments:
      op.error( 'You need to specify an input filename.' )
   if len( arguments ) > 1:
      op.error( 'Too many input arguments.' )

   tsData = _readTimestamps( arguments[ 0 ], opts.fcs )
   _printTimestamps( tsData, opts.pcap, opts.utc, opts.ticks, 
                     opts.delta, opts.src, opts.filename )

if __name__ == '__main__':
   main()
